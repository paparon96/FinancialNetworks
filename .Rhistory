# Create vectors for network visualisation
n = length(varnames)*(length(varnames)-1)
orig = vector(mode="character", length=n)
dest = vector(mode="character", length=n)
weight <- rep(0, n)
# Fill vectors with the data
k = 0
for (i in 1:length(varnames)){
for (j in 1:length(varnames)){
if (i != j){
orig[k] = varnames[i]
dest[k] = varnames[j]
weight[k] = network_matrix[i,j]
k = k + 1
}
}
}
# Create dataframe from vectors
df<- data.frame(orig, dest,
weight)
# Visualisation
rownames(network_matrix) = varnames
colnames(network_matrix) = varnames
diag(network_matrix) <- 0
circos.clear()
title = "./Figures/DY_return_resid_method_network_chord_diagram.pdf"
pdf(title)
chordDiagram(network_matrix, directional = 1,
direction.type = c("diffHeight", "arrows"),
link.arr.type = "big.arrow")
dev.off()
## OPTION 3: volatility - no factor
# Import data
temp = read.csv("./Data/Estimated_networks/Volatility_spillover.csv", sep=",", row.names=1)
# Get relevant entries
temp = temp[1:10,1:10]
temp = temp / 100
View(temp)
# Transform to matrix format
network_matrix = as.matrix(temp)
# Parameters
varnames = c("MS","JPM","BAC","C","WFC","GS","USB","TD","BK","TFC")
# Create vectors for network visualisation
n = length(varnames)*(length(varnames)-1)
orig = vector(mode="character", length=n)
dest = vector(mode="character", length=n)
weight <- rep(0, n)
# Fill vectors with the data
k = 0
for (i in 1:length(varnames)){
for (j in 1:length(varnames)){
if (i != j){
orig[k] = varnames[i]
dest[k] = varnames[j]
weight[k] = network_matrix[i,j]
k = k + 1
}
}
}
# Create dataframe from vectors
df<- data.frame(orig, dest,
weight)
# Visualisation
rownames(network_matrix) = varnames
colnames(network_matrix) = varnames
diag(network_matrix) <- 0
circos.clear()
title = "./Figures/DY_volatility_method_network_chord_diagram.pdf"
pdf(title)
chordDiagram(network_matrix, directional = 1,
direction.type = c("diffHeight", "arrows"),
link.arr.type = "big.arrow")
dev.off()
## OPTION 4: volatility - with factor
# Import data
temp = read.csv("./Data/Estimated_networks/Volatility_spillover_resid.csv", sep=",", row.names=1)
# Get relevant entries
temp = temp[1:10,1:10]
temp = temp / 100
# Transform to matrix format
network_matrix = as.matrix(temp)
View(temp)
# Parameters
varnames = c("MS","JPM","BAC","C","WFC","GS","USB","TD","BK","TFC")
# Create vectors for network visualisation
n = length(varnames)*(length(varnames)-1)
orig = vector(mode="character", length=n)
dest = vector(mode="character", length=n)
weight <- rep(0, n)
# Fill vectors with the data
k = 0
for (i in 1:length(varnames)){
for (j in 1:length(varnames)){
if (i != j){
orig[k] = varnames[i]
dest[k] = varnames[j]
weight[k] = network_matrix[i,j]
k = k + 1
}
}
}
# Create dataframe from vectors
df<- data.frame(orig, dest,
weight)
# Visualisation
rownames(network_matrix) = varnames
colnames(network_matrix) = varnames
diag(network_matrix) <- 0
circos.clear()
title = "./Figures/DY_volatility_resid_method_network_chord_diagram.pdf"
pdf(title)
chordDiagram(network_matrix, directional = 1,
direction.type = c("diffHeight", "arrows"),
link.arr.type = "big.arrow")
dev.off()
View(temp)
# Import packages
library(space)
library(glasso)
library(dplyr)
library(ggplot2)
# Import custom functions
source("common_functions.R")
# Import data
df <- read.table('./Data/Stock_prices/log_returns_all_ts.csv',sep=",", header=TRUE)
## Global parameters
var_cols = c("MS","JPM","BAC","C","WFC","GS","USB","TD","BK","TFC")
N = dim(stock_df)[1]
window_length = 150
final_date = as.Date("2020-06-30")
final_date_loc = match(final_date,as.Date(df$Date))
start_date_loc = final_date_loc - window_length #final_date - window_length
# Filter dataset based on the dates
#filtered_df = subset(df,as.Date(Date) >= start_date)
#filtered_df = subset(filtered_df, final_date > as.Date(Date))
filtered_df = df[start_date_loc:(final_date_loc-1),]
filtered_df = filtered_df[var_cols]
# Inspect the results
plot(filtered_df$MS)
# Standardize final dataset
filtered_df <- scale(filtered_df)
## Run the model
# Neighbourhood selection
#################### estimate the partial correlation matrix with various methods
alpha=1
l1=(1/sqrt(n)*qnorm(1-alpha/(2*p^2)))*0.7
iter=3
n=nrow(filtered_df)
p=ncol(filtered_df)
result1=space.neighbor(data.matrix(filtered_df), lam1=l1, lam2=0)
print(result1)
estimated_partial_corr_matrix = result1$ParCor
# Hyperparameter tuning - penalty terms
## Export results
write.csv(estimated_partial_corr_matrix,'./Data/Estimated_networks/NE.csv')
## METHOD PART 2: Run combined model
# Import factors
five_factors_df <- read.table('./Data/Stock_prices/F-F_Research_Data_5_Factors_2x3_daily.CSV',sep=",", header=TRUE)
## parameters
var_cols = c("Mkt.RF","SMB","HML","RMW","CMA","RF")
window_length = 150
final_date = "30/06/2020"
final_date_loc = match(final_date,five_factors_df$Date)
start_date_loc = final_date_loc - window_length #final_date - window_length
filtered_factor_df = five_factors_df[start_date_loc:(final_date_loc-1),]
filtered_factor_df = filtered_factor_df[var_cols]
# Inspect the results
plot(filtered_factor_df$SMB)
# Standardize final dataset
filtered_factor_df <- scale(filtered_factor_df)
# Combine arrays
combined_filtered_df <- cbind(filtered_df,filtered_factor_df)
final_date_loc
start_date_loc
# Import factors
five_factors_df <- read.table('./Data/Stock_prices/F-F_Research_Data_5_Factors_2x3_daily.CSV',sep=",", header=TRUE)
## parameters
var_cols = c("Mkt.RF","SMB","HML","RMW","CMA","RF")
window_length = 150
final_date = "30/06/2020"
final_date_loc = match(final_date,five_factors_df$Date)
start_date_loc = final_date_loc - window_length #final_date - window_length
filtered_factor_df = five_factors_df[start_date_loc:(final_date_loc-1),]
filtered_factor_df = filtered_factor_df[var_cols]
# Inspect the results
plot(filtered_factor_df$SMB)
# Standardize final dataset
filtered_factor_df <- scale(filtered_factor_df)
# Combine arrays
combined_filtered_df <- cbind(filtered_df,filtered_factor_df)
# Import packages
library(space)
library(glasso)
library(dplyr)
library(ggplot2)
# Import custom functions
source("common_functions.R")
# Import data
df <- read.table('./Data/Stock_prices/log_returns_all_ts.csv',sep=",", header=TRUE)
## Global parameters
var_cols = c("MS","JPM","BAC","C","WFC","GS","USB","TD","BK","TFC")
N = dim(stock_df)[1]
window_length = 150
final_date = as.Date("2020-06-30")
final_date_loc = match(final_date,as.Date(df$Date))
start_date_loc = final_date_loc - window_length #final_date - window_length
# Filter dataset based on the dates
#filtered_df = subset(df,as.Date(Date) >= start_date)
#filtered_df = subset(filtered_df, final_date > as.Date(Date))
filtered_df = df[start_date_loc:(final_date_loc-1),]
filtered_df = filtered_df[var_cols]
# Inspect the results
plot(filtered_df$MS)
# Standardize final dataset
filtered_df <- scale(filtered_df)
# Import data
df <- read.table('./Data/Stock_prices/log_returns_all_ts.csv',sep=",", header=TRUE)
## Global parameters
var_cols = c("MS","JPM","BAC","C","WFC","GS","USB","TD","BK","TFC")
#N = dim(stock_df)[1]
window_length = 150
final_date = as.Date("2020-06-30")
final_date_loc = match(final_date,as.Date(df$Date))
start_date_loc = final_date_loc - window_length #final_date - window_length
# Filter dataset based on the dates
#filtered_df = subset(df,as.Date(Date) >= start_date)
#filtered_df = subset(filtered_df, final_date > as.Date(Date))
filtered_df = df[start_date_loc:(final_date_loc-1),]
filtered_df = filtered_df[var_cols]
final_date_loc
View(df)
View(df)
# Import custom functions
source("common_functions.R")
# Import data
df <- read.table('./Data/Stock_prices/log_returns_all_ts.csv',sep=",", header=TRUE)
## Global parameters
var_cols = c("MS","JPM","BAC","C","WFC","GS","USB","TD","BK","TFC")
#N = dim(stock_df)[1]
window_length = 150
final_date = "30/06/2020"   #as.Date("2020-06-30")
final_date_loc = match(final_date,as.Date(df$Date))
final_date_loc
View(temp)
View(df)
final_date_loc = match(final_date,df$Date)
start_date_loc = final_date_loc - window_length #final_date - window_length
# Filter dataset based on the dates
#filtered_df = subset(df,as.Date(Date) >= start_date)
#filtered_df = subset(filtered_df, final_date > as.Date(Date))
filtered_df = df[start_date_loc:(final_date_loc-1),]
filtered_df = filtered_df[var_cols]
# Inspect the results
plot(filtered_df$MS)
# Standardize final dataset
filtered_df <- scale(filtered_df)
combined_filtered_df <- cbind(filtered_df,filtered_factor_df)
## Run the model
# Neighbourhood selection
#################### estimate the partial correlation matrix with various methods
alpha=1
l1=(1/sqrt(n)*qnorm(1-alpha/(2*p^2)))*0.7
iter=3
n=nrow(combined_filtered_df)
p=ncol(combined_filtered_df)
result1=space.neighbor(data.matrix(combined_filtered_df), lam1=l1, lam2=0)
print(result1)
estimated_partial_corr_matrix = result1$ParCor
# Hyperparameter tuning - penalty terms
## Export results
write.csv(estimated_partial_corr_matrix,'./Data/Estimated_networks/NE_combined_factors.csv')
n=nrow(combined_filtered_df)
p=ncol(combined_filtered_df)
alpha=1
l1=(1/sqrt(n)*qnorm(1-alpha/(2*p^2)))*0.7
iter=3
result1=space.neighbor(data.matrix(combined_filtered_df), lam1=l1, lam2=0)
print(result1)
estimated_partial_corr_matrix = result1$ParCor
# Hyperparameter tuning - penalty terms
## Export results
write.csv(estimated_partial_corr_matrix,'./Data/Estimated_networks/NE_combined_factors.csv')
factor_residual_matrix <- get_residuals(filtered_df,filtered_factor_df)
factor_residual_matrix <- scale(factor_residual_matrix)
# Neighbourhood selection
#################### estimate the partial correlation matrix with various methods
n=nrow(factor_residual_matrix)
p=ncol(factor_residual_matrix)
alpha=1
l1=(1/sqrt(n)*qnorm(1-alpha/(2*p^2)))*0.7
iter=3
result1=space.neighbor(data.matrix(factor_residual_matrix), lam1=l1, lam2=0)
print(result1)
estimated_partial_corr_matrix = result1$ParCor
write.csv(estimated_partial_corr_matrix,'./Data/Estimated_networks/NE_factor_residuals.csv')
CreateRollingDataFrame <- function( rolling_spills, within = T ){
rows <- nrow( as.data.frame( overall( rolling_spills, within ) ) )
spills_data <- as.data.frame( matrix( nrow = rows, ncol = 76 ) )
spills_data[ , 1 ] <- as.data.frame( overall(rolling_spills, within ) )
spills_data[ , 2:11 ] <- as.data.frame( to( rolling_spills, within ) )
spills_data[ , 12:21 ] <- as.data.frame( from( rolling_spills, within ) )
spills_data[ , 22:31 ] <- as.data.frame( net( rolling_spills, within ) )
spills_data[ , 32:76 ] <- as.data.frame( pairwise( rolling_spills, within ) )
colnames( spills_data ) <- c( "Total", colnames( as.data.frame( to( rolling_spills, within ) ) ),
colnames( as.data.frame( from( rolling_spills, within ) ) ),
colnames( as.data.frame( net( rolling_spills, within ) ) ),
colnames( as.data.frame( pairwise( rolling_spills, within ) ) )
)
return( spills_data )
}
LoadLibraries <- function(){
library( BigVAR )
library( readxl )
library( lattice )
library( strucchange )
library( vars )
library( psych )
library( tseries )
library( tidyverse )
library( RColorBrewer )
library( devtools )
library( frequencyConnectedness )
library( stats )
library( PerformanceAnalytics )
library( zoo )
library( ggplot2 )
library( igraph )
library( extrafont )
windowsFonts( A = windowsFont( "Times New Roman" ) )
}
NetPairwiseSpilloversThreshold <- function( spill_table, threshold ){
spill_table <- as.data.frame( spill_table$tables[ 1 ] )
net_table <- data.frame( matrix( nrow = ( length( spill_table ) * ( length( spill_table ) - 1 ) / 2 ), ncol = 4 ) )
colnames( net_table ) <- c( "Source", "Target", "Type", "Weight" )
count <- 0
n <- 1
for ( i in 1:length( spill_table ) ){
for ( j in n:length( spill_table ) ){
if ( i != j ){
if( abs( ( spill_table[ j, i ] - spill_table[ i, j ] ) ) >= threshold ){
count <- count + 1
net_table$Type[ count ] <- "Directed"
if( ( spill_table[ j, i ] - spill_table[ i, j ] ) > 0 ){
net_table$Source[ count ] <- colnames( spill_table )[ i ]
net_table$Target[ count ] <- rownames( spill_table )[ j ]
net_table$Weight[ count ] <- spill_table[ j, i ] - spill_table[ i, j ]
}else{
net_table$Source[ count ] <- colnames( spill_table )[ j ]
net_table$Target[ count ] <- rownames( spill_table )[ i ]
net_table$Weight[ count ] <- - ( spill_table[ j, i ] - spill_table[ i, j ] )
}
}
}
}
n <- n + 1
}
net_table <- drop_na( net_table )
graph_names <- c()
weights <- c()
for ( i in 1:nrow( net_table ) ){
graph_names <- c( graph_names, net_table[ i, 1 ] )
graph_names <- c( graph_names, net_table[ i, 2 ] )
weights <- c( weights, net_table[ i, 4 ] )
}
net_data <- list( table = net_table, names = graph_names, weights = weights )
return( net_data )
}
# Load the necessary libraries
LoadLibraries()
#Load libraries
LoadLibraries()
return <- list()
# Loading data
return$data <- list()
return$data$return <- as.data.frame( read.csv( "Data/Stock_prices/log_returns_all_ts.csv", header = TRUE, sep = "," ) )
return$data$return$Date <- format( as.Date( return$data$return$Date, format = "%d/%m/%Y" ), "%Y-%m-%d" )
risk_factors_5 <- as.data.frame( read.csv( "Data/Stock_prices/F-F_Research_Data_5_Factors_2x3_daily.CSV", header = TRUE, sep = "," ))
vol <- list()
# Loading data
vol$data <- list()
vol$data$high_low <- cbind( as.data.frame( read.csv( "Data/Stock_prices/high_price.csv", header = TRUE, sep = "," ) ),
as.data.frame( read.csv( "Data/Stock_prices/low_price.csv", header = TRUE, sep = "," ) )[ , -1 ] )
colnames( vol$data$high_low )[ 1 ] <- "Date"
vol$data$high_low$Date <- as.Date( format( as.Date( vol$data$high_low$Date, format = "%d/%m/%Y" ), "%Y-%m-%d"))
risk_factors_5 <- as.data.frame( read.csv( "Data/Stock_prices/F-F_Research_Data_5_Factors_2x3_daily.CSV", header = TRUE, sep = "," ))
# Calculating the annualized daily percent standard deviation
vol$data$volatility <- as.data.frame( matrix( nrow = nrow( vol$data$high_low ), ncol = ncol( vol$data$high_low[ , -1 ] ) / 2 + 1 ) )
vol$data$volatility[ , 1 ] <- vol$data$high_low$Date
for( i in 1:10 ){
vol$data$volatility[ , i + 1 ] <- log( 100 * sqrt( 365 * 0.361 * ( log( vol$data$high_low[ , i + 1 ] ) -  log( vol$data$high_low[ , i + 11 ] ) )^2 ) )
}
colnames( vol$data$volatility ) <- colnames( vol$data$high_low )[ 1:11 ]
vol$data$volatility_risk_factors <- as.data.frame( cbind( vol$data$volatility[ 2500, ], risk_factors_5[ , -1 ] ))
# Set parameters for the network to plot
threshold <- 0.0
arrow_size <- 0.8
edge_size <- 200
window <- 150
# Last date of window
date <- as.Date( "2020-03-05" )
# Function to plot graph (first run the function's code)
graphs <- PlotNetworks( date, "Volatility", window, vol$data$volatility, arrow_size, edge_size, threshold )
# Function
PlotNetworks <- function( date, measure, window, data, arrow_size, edge_size, threshold ){
rownames( data ) <- c( 1:length( data$Date ) )
end_date <- as.numeric( rownames( data[ as.Date( data$Date ) == date, ] ) )
start_date <- end_date - 199
graph_var <- VAR( subset( data[ start_date:end_date, ], select = -c( Date ) ), p = 2, type = "const" )
graph_spill <- spilloverDY12( graph_var, n.ahead = 10, no.corr = F )
graph <- NetPairwiseSpilloversThreshold( graph_spill, threshold )
graph$graph <- make_graph( graph$names, directed = T, isolates = setdiff( colnames( vol$data$volatility[ , -1 ] ), graph$names ) )
graph$graph <- set_edge_attr( graph$graph, "weight", value = ( graph$weights * edge_size ) )
par( mar = c( 0, 0, 2.5, 0 ), mfrow = c( 1, 1 ), cex = 0.9 )
vt_coords <- layout_in_circle( graph$graph, order = order( V( graph$graph )$name, decreasing = T ) )
vt_plot <- plot( graph$graph, layout = vt_coords, vertex.size = 3,
vertex.label.dist = 0.5, vertex.color = "red", edge.arrow.size = arrow_size,
edge.width = E( graph$graph )$weight, family = "A", main = measure )
mtext( paste( data$Date[ end_date ] ), side = 3, line = -2.8, family = "A", outer = TRUE, cex = 0.9 )
network <- list( VAR = graph_var, spill = graph_spill, graph = graph, plot = plot )
return( network )
}
# Function to plot graph (first run the function's code)
graphs <- PlotNetworks( date, "Volatility", window, vol$data$volatility, arrow_size, edge_size, threshold )
graphs <- PlotNetworks( date, "Return", window, return$data$return[ , -1 ], arrow_size, edge_size, threshold )
return$factors <- list()
return$factors$resid <- lapply( return$data$return[ , -c( 1, 2 ) ], function( y ) print( summary( lm( y ~ risk_factors_5$Mkt.RF + risk_factors_5$SMB +
risk_factors_5$HML + risk_factors_5$RMW + risk_factors_5$CMA +
risk_factors_5$RF ))))
return$factors$resid <- as.data.frame( lapply( return$data$return[ , -c( 1, 2 ) ], function( y ) resid( lm( y ~ risk_factors_5$Mkt.RF + risk_factors_5$SMB +
risk_factors_5$HML + risk_factors_5$RMW + risk_factors_5$CMA +
risk_factors_5$RF ))))
colnames( return$factors$resid ) <- colnames( return$data$return[ , -c( 1, 2 ) ] )
return$factors$resid$Date <- return$data$return$Date
vol$factors <- list()
vol$factors$resid <- lapply( vol$data$volatility[ , -1 ], function( y ) print( resid( lm( y ~ risk_factors_5$Mkt.RF + risk_factors_5$SMB +
risk_factors_5$HML + risk_factors_5$RMW + risk_factors_5$CMA +
risk_factors_5$RF ))))
vol$factors$resid <- as.data.frame( lapply( vol$data$volatility[ , -1 ], function( y ) resid( lm( y ~ risk_factors_5$Mkt.RF + risk_factors_5$SMB +
risk_factors_5$HML + risk_factors_5$RMW + risk_factors_5$CMA +
risk_factors_5$RF ))))
colnames( vol$factors$resid ) <- colnames( vol$data$volatility[ , -1 ] )
vol$factors$resid$Date <- vol$data$volatility$Date
# Function to plot graph (first run the function's code)
graphs <- PlotNetworks( date, "Volatility", window, vol$data$volatility, arrow_size, edge_size, threshold )
graphs$spill
graphs <- PlotNetworks( date, "Volatility", window, vol$factors$resid, arrow_size, edge_size, threshold )
graphs$spill
library(BigVAR)
?constructModel
big_var_est <- function(data) {
Model1 = constructModel( as.matrix(data), p = 2, struct = "Basic", gran = c(50, 50), VARX = list(), verbose = F)
Model1Results = cv.BigVAR(Model1)
}
length(vol$data$volatility$Date)
vol$data$volatility$Date[ 2200:2300 ]
vol$data$volatility$Date[ 2400:2500 ]
vol$data$volatility$Date[ 2350:2400 ]
vol$data$volatility$Date[ 2377:2400 ]
vol$data$volatility$Date[ 2375:2400 ]
nrow(vol$data$volatility[ 2226:2375, -1 ])
# Perform the estimation
oo <- big_var_est(vol$data$volatility[ 2226:2375, -1 ])
spilloverDY12(oo, n.ahead = 10, no.corr = F)
Model1 = constructModel( as.matrix(data), p = 2, struct = "Basic", gran = c(50, 10), VARX = list(), verbose = F)
big_var_est <- function(data) {
Model1 = constructModel( as.matrix(data), p = 2, struct = "Basic", gran = c(50, 10), VARX = list(), verbose = F)
Model1Results = cv.BigVAR(Model1)
}
# Perform the estimation
oo <- big_var_est(vol$data$volatility[ 2226:2375, -1 ])
spilloverDY12(oo, n.ahead = 10, no.corr = F)
Model1 = constructModel( as.matrix(data), p = 2, struct = "Basic", gran = c(10, 10), VARX = list(), verbose = F)
big_var_est <- function(data) {
Model1 = constructModel( as.matrix(data), p = 2, struct = "Basic", gran = c(10, 10), VARX = list(), verbose = F)
Model1Results = cv.BigVAR(Model1)
}
# Perform the estimation
oo <- big_var_est(vol$data$volatility[ 2226:2375, -1 ])
spilloverDY12(oo, n.ahead = 10, no.corr = F)
big_var_est <- function(data) {
Model1 = constructModel( as.matrix(data), p = 2, struct = "Basic", gran = c(1, 1), VARX = list(), verbose = F)
Model1Results = cv.BigVAR(Model1)
}
# Perform the estimation
oo <- big_var_est(vol$data$volatility[ 2226:2375, -1 ])
spilloverDY12(oo, n.ahead = 10, no.corr = F)
big_var_est <- function(data) {
Model1 = constructModel( as.matrix(data), p = 2, struct = "Basic", gran = c(0.1, 0.1), VARX = list(), verbose = F)
Model1Results = cv.BigVAR(Model1)
}
# Perform the estimation
oo <- big_var_est(vol$data$volatility[ 2226:2375, -1 ])
big_var_est <- function(data) {
Model1 = constructModel( as.matrix(data), p = 2, struct = "Basic", gran = c(10, 1), VARX = list(), verbose = F)
Model1Results = cv.BigVAR(Model1)
}
# Perform the estimation
oo <- big_var_est(vol$data$volatility[ 2226:2375, -1 ])
spilloverDY12(oo, n.ahead = 10, no.corr = F)
oo
# Function to plot graph (first run the function's code)
graphs <- PlotNetworks( date, "Volatility", window, vol$data$volatility, arrow_size, edge_size, threshold )
graphs$spill
# Function to plot graph (first run the function's code)
graphs <- PlotNetworks( date, "Volatility", window, vol$data$volatility, arrow_size, edge_size, threshold )
graphs$spill
graphs <- PlotNetworks( date, "Volatility", window, vol$factors$resid, arrow_size, edge_size, threshold )
graphs$spill
graphs <- PlotNetworks( date, "Return", window, return$data$return[ , -1 ], arrow_size, edge_size, threshold )
graphs$spill
graphs <- PlotNetworks( date, "Return", window, return$factors$resid, arrow_size, edge_size, threshold )
graphs$spill
